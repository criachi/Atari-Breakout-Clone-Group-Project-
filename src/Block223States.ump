class PlayedGame {

  // State Machine
  
  playStatus {
    Ready {
      entry / { doSetup(); }
      play -> Moving;
    }
    Moving {
      pause -> Paused;
      move [hitPaddle()] / { doHitPaddleOrWall(); } -> Moving;
      move [isOutOfBoundsAndLastLife()] / { doOutOfBounds(); } -> GameOver;
      move [isOutOfBounds()] / { doOutOfBounds(); } -> Paused;
      move [hitLastBlockAndLastLevel()] / { doHitBlock(); } -> GameOver;
      move [hitLastBlock()] / { doHitBlockNextLevel(); } -> Ready;
      move [hitBlock()] / { doHitBlock(); } -> Moving;
      move [hitWall()] / { doHitPaddleOrWall(); } -> Moving;
      move / { doHitNothingAndNotOutOfBounds(); } -> Moving;
    }
    Paused {
      play -> Moving;
    }
    GameOver {
      entry / { doGameOver(); }
    }
  }
  
  // Guards
  // TODO implement bounceBall
  
  private boolean hitPaddle() {
    // TODO implement
    return false;
  }

  private boolean isOutOfBoundsAndLastLife() {
   	if (getLives() == 1){ 
     return isOutOfBounds();
     }
     return false;
  }
  
  private boolean isOutOfBounds() {
    if ( getCurrentBallY() > getCurrentPaddleY()){
    return true;
    }    
    return false;
  }
  
  //Onur Cayci - ball hits block method
  
  private boolean hitLastBlockAndLastLevel() {
    Game game = this.getGame();
    int nrLevels = game.numberOfLevels();
    this.setBounce(null);
    if(nrLevels == this.currentLevel) {
    	int nrBLocks = this.numberOfBlocks();
    	if(nrBlocks == 1) {
    		PlayedBlockAssignment block = this.getBlock(0);
    		BouncePoint bp = this.calculateBouncePointBlock(block);
    		if(bp == null) {
    			return null;
    		}
    		this.setBounce(bp);
    		return true;
    	}
    }
    return false;
  }
  
  //Onur Cayci - ball hits block method
  
  private boolean hitLastBlock(){
    int nrBlocks = this.numberOfBlocks();
    this.setBounce(null);
    if(nrBlocks == 1) {
    	PlayedBlockAssignment block = this.getBlock(0);
    	BouncePoint bp = calculateBouncePointBlock(block);
    	if(bp == null) {
    		return null;
    	}
    	this.setBounce(bp);
    	return true;
    }
    return false;
  }
  
  //Onur Cayci - ball hits block method
  
  private boolean hitBlock() {
    int nrBlocks = this.numberOfBlocks();
    this.setBounce(null);
    for(int i = 0; i < nrBlocks; i++) {
    	PlayedBlockAssignment block = this.getBlock(i);
    	BouncePoint bp = calculateBouncePointBlock(block);
    	if(bp == null) {
    		return null;
    	}
    	BouncePoint bounce = this.getBounce();
    	boolean closer = isCloser(bp, bounce);
    	if(closer) {
    		this.setBounce(bp);
    	}
    }
    return this.getBounce() != null;
  }
  
  private boolean hitWall() {
    // TODO implement
    return false;
  }
  
  // Actions
  
  private void doSetup() {
    // TODO implement
  }
  
  private void doHitPaddleOrWall() {
    // TODO implement
  }

  private void doOutOfBounds() {
     setLives (lives-1);
     resetCurrentBallX();
     resetCurrentBallY();
     resetBallDirectionX();
     resetBallDirectionY();
     resetCurrentPaddleX();
  }
  
  //Onur Cayci - ball hits block method
  
  private void doHitBlock() {
    int score = this.getScore();
    BouncePoint bounce = this.getBounce();
    PlayedBlockAssignment pblock = bounce.getHitBlock();
    Block block = pblock.getBlock();
    int bscore = block.getPoints();
    this.setScore(score + bscore);
    pblock.delete();
    this.bounceBall();
  }
  
  //Onur Cayci - ball hits block method
  
  private void doHitBlockNextLevel() {
    this.doHitBlock();
    int level = this.getCurrentLevel();
    this.setCurrentLevel(level + 1);
    this.setCurrentPaddleLength(getGame().getPaddle().getMaxPaddleLength() - (getGame().getPaddle().getMinPaddleLength()) / (getGame().numberOfLevels()-1)*(getCurrentLevel()-1));
    this.setWaitTime(INITIAL_WAIT_TIME * getGame().getBall().getBallSpeedIcreaseFactor() ^ (getCurrentLevel()-1))
  }

  private void doHitNothingAndNotOutOfBounds() {
    // TODO implement
  }

  private void doGameOver(){
    Block223 block223 = getBlock223();
    Player p  = getPlayer();
    if ( p != null){
    	HallOfFameEntry hof = new HallOfFameEntry (score,playername,p,game,block223);
    	Game game = getGame();
    	game.setMostRecentEntry(hof);
    	}
    p.delete();
  }
  
  //Onur Cayci - ball hits block method
  
  private boolean isCloser(BouncePoint first, BouncePoint second) {
  	if(first == null) {
  		return false;
  	}
  	if(second == null) {
  		return true;
  	}
  	double distance1 = sqrt(((first.getX() - getCurrentBallX())*(first.getX() - getCurrentBallX()))+((first.getY() - getCurrentBallY())*(first.getY() - getCurrentBallY())));
  	double distance2 = sqrt(((second.getX() - getCurrentBallX())*(second.getX() - getCurrentBallX()))+((second.getY() - getCurrentBallY())*(second.getY() - getCurrentBallY())));
  	if(distance1 < distance2) {
  		return true;
  	}
  	return false;
  }
  
  //Onur Cayci - ball hits block method
 
  private BouncePoint calculateBoincePointBlock(PlayedBlockAssignment block) {
  	int blockX = 25 * (block.getX() - 1); //top left corner x-coordinate of the block
  	int blockY = 22 * (block.getY() - 1); //top left corner y-coordinate of the block
  	Rectangle2D rect = new Rectangle2D.Double(blockX, blockY, 40, 40);
  	Ellipse2D ball = new Ellipse2D.Double(getCurrentBallX() + getBallDirectionX(); getCurrentBallY() + getBallDirectionY(); 10, 10);
  	if(!rect.intersectsLine(ball)) return null;
  	
  	//if the ball comes from the top
  	
  	if(blockY > getBallY()) {
  	//option A
  		if((getBallX() + getBallDirectionX()) != blockX || (getBallX() + getBallDirectionX()) != (getBallX() + 20)) {
  			return BouncePoint bp = new BouncePoint(getBallX() + getBallDirectionX(), blockY, FLIP_Y);
  		}
  	//option E
  		if((getBallX() + getBallDirectionX()) = blockX) { //might need to add extra if statement to better detect the bounce on the edge, it should be good so far without it
  			return new BouncePoint(blockX, blockY, FLIP_Y);
  		}
  	//option F
  		if((getBallX() + getBallDirectionX() = (blockX + 20)) {
  			return new BouncePoint(blockX + 20, blockY, FLIP_X);
  		} 
  	}
  	
  	//if the ball comes from the bottom
  	
  	if((blockY + 20) < getBallY()) {
  	//option D
  		if((getBallX() + getBallDirectionX()) != blockX || (getBallX() + getBallDirectionX()) != (getBallX() + 20)) {
  			return new BouncePoint(getBallX() + getBallDirectionX(), blockY + 20, FLIP_Y);
  		}
  	//option G
  		if((getBallX() + getBallDirectionX()) = blockX) { //might need to add extra if statement to better detect the bounce on the edge, it should be good so far without it
  			return new BouncePoint(blockX, blockY + 20, FLIP_Y);
  		}
  	//option H
  		if((getBallX() + getBallDirectionX() = (blockX + 20)) {
  			return new BouncePoint(blockX + 20, blockY + 20, FLIP_X);
  		}
  	}
  	
  	//if the ball comes from the left
  	
  	if(blockX > getBallX()) {
  	//option B
  	if((getBallY() + getBallDirectionY()) != blockY || (getBallY() + getBallDirectionY()) != (getBallY() + 20)) {
  			return new BouncePoint(blockX, getBallY() + getBallDirectionY(), FLIP_X);
  		}
  	//option E
  		if((getBallY() + getBallDirectionY()) = blockY) { //might need to add extra if statement to better detect the bounce on the edge, it should be good so far without it
  			return new BouncePoint(blockX, blockY, FLIP_X);
  		}
  	//option G
 		if((getBallY() + getBallDirectionY() = (blockY + 20)) {
  			return new BouncePoint(blockX, blockY + 20, FLIP_X);
  		}
  	}
  	
  	//if the ball comes from the right
  	
  	if(blockX + 20 < getBallX()) {
  	//option C
  		if((getBallY() + getBallDirectionY()) != blockY || (getBallY() + getBallDirectionY()) != (getBallY() + 20)) {
  			return new BouncePoint(blockX + 20, getBallY() + getBallDirectionY(), FLIP_X);
  		}
  	//option F
  		if((getBallY() + getBallDirectionY()) = blockY) { //might need to add extra if statement to better detect the bounce on the edge, it should be good so far without it
  			return new BouncePoint(blockX + 20, blockY, FLIP_Y);
  		}
  	//option H
  		if((getBallY() + getBallDirectionY() = (blockY + 20)) {
  			return new BouncePoint(blockX + 20, blockY + 20, FLIP_Y);
  		}
  	}
}
