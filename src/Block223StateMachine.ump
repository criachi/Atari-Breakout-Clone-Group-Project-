class PlayedGame {
	// attribute name for state machine 
	gameStatus {
		// initial default state we go into 
		Idle {
			beginGame() [hasEnoughBlockAssignments()] / {
				doInitializeBlockAssignments(); //this copies over info from EXISTING blockAssignments to specificBlockAssignments	
				doInitializeBallandPaddle();
			} -> Play;
			beginGame() [!hasEnoughBlockAssignments()] / {
				doInitializeBlockAssignments();
				doPutRandomBlocks();
				doInitializeBallandPaddle();
			} -> Play;
		}
		Play {
			pause() -> Paused;
			move [isPaddleHit()] / {doBounceBackFromPaddle(getSpecificBall()); doMoveBall();} -> Play;
			move [isWallHit()] / {doBounceBackFromWall(getSpecificBall()); doMoveBall(); } -> Play;
			move [isBlockHit() && isLastBlock() && isLastLevel()] / { doBounceBackFromBlock(getSpecificBall()); doUpdateScore(); doDeleteSpecificBlock(); doMoveBall();} -> Done; //u will have helper method that gets reference of the specific block assignment whose pos coincides w/ ball's 
			move [isBlockHit() && isLastBlock() && !isLastLevel()] / { doBounceBackFromBlock(getSpecificBall()); doUpdateScore(); doDeleteSpecificBlock(); doIncreaseLevel(); doMoveBall();} -> Paused; //come back to this
			move [isBlockHit()] / { doBounceBackFromBlock(getSpecificBall()); doUpdateScore(); doDeleteSpecificBlock(); doMoveBall(); } -> Play; // come back 
			move [isBallOutOfBounds() && (hasOneLifeRemaining())] / {doDecrementLives(); doResetBallandPaddle(); doMoveBall(); } -> Done;
			move [isBallOutOfBounds()] / {doDecrementLives(); doMoveBall(); } -> Paused;
		}
		Paused {
			resume() -> Play;
		}
		Done {
			entry / {
				doUpdateScore();
				doDeletePlayedGame();
			}
		}
		
		
		
	}
	
	private void doMoveBall() {
	}
	private void doInitializeBlockAssignments() {
	}
	
	private void doInitializeBallandPaddle() {
	}
	
	private Boolean hasEnoughBlockAssignments() {
	return false;
	}
	
	private void doUpdateScore() {
	}
	private void doDeletePlayedGame() {
	}

	private Boolean hasOneLifeRemaining() {
	return false;
	}
	
	private Boolean isBallOutOfBounds() {
	return false;
	}
	
	private Boolean isBlockHit() {
	return false;
	}
	
	private void doBounceBackFromBlock(SpecificBall aBall){
	}
	
	private void doDecrementLives() {
	}
	
	private void doResetBallandPaddle() {
	}
	
	private Boolean isPaddleHit() {
	return false;
	}
	
	private Boolean isWallHit() {
	return false;
	}
	
	private void doBounceBackFromPaddle(SpecificBall aBall) {
	}
	
	private void doBounceBackFromWall(SpecificBall aBall) {
	}
	
	private void doUpdateScore (){
	
	}
	
	private void doDeleteSpecificBlock() {
	}
	
	private void doIncreaseLevel() { 
	}
	
	private Boolean isLastLevel(){
	return false;
	}
	
	private Boolean isLastBlock() {
	return false;	
	}
	
	private void doPutRandomBlocks() {
	}
	
}

